# Linux 的常用工具

## GDB

GDB 是一个由 GNU 开源组织发布的、UNIX/LINUX 操作系统下的、基于命令行的、功能强大的程序调试工具。 对于一名 Linux 下工作的 C++ 程序员，gdb 是必不可少的工具。

```shell
gdb
```

## LDD

用来查看程式运行所需的共享库,常用来解决程式因缺少某个库文件而不能运行的一些问题。

```shell
ldd 
```

相关原理：ldd 不是个可执行程式，而只是个 shell 脚本。ldd 显示可执行模块的 dependency 的工作原理，其实质是通过 ld-linux.so（ elf 动态库的装载器）来实现的。ld-linux.so 模块会先于 executable 模块程式工作，并获得控制权，因此当上述的那些环境变量被设置时，ld-linux.so 选择了显示可执行模块的 dependency 。

## LSOF

lsof（ list open files ）是一个查看当前系统文件的工具。在 linux 环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。如传输控制协议 ( TCP ) 和用户数据报协议 ( UDP ) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，该文件描述符提供了大量关于这个应用程序本身的信息。

适配的文件类型：

- 普通文件
- 目录
- 网络文件系统的文件
- 字符或设备文件
- (函数)共享库
- 管道，命名管道
- 符号链接
- 网络文件（例如：NFS file ，网络 socket，Unix 域名 socket）
- 还有其它类型的文件
- 等等

使用命令为 

```shell
lsof 
```

## PSTACK

此命令可显示每个进程的栈跟踪。pstack 命令必须由相应进程的属主或 root 运行。可以使用 pstack 来确定进程挂起的位置。此命令允许使用的唯一选项是要检查的进程的 PID 。

这个命令在排查进程问题时非常有用，比如我们发现一个服务一直处于work状态（如假死状态，好似死循环），使用这个命令就能轻松定位问题所在；可以在一段时间内，多执行几次 pstack，若发现代码栈总是停在同一个位置，那个位置就需要重点关注，即可能是出问题的地方。

```shell
pstack <pid>
```

## STRACE

strace 常用来跟踪进程执行时的系统调用和所接收的信号。 在 Linux 世界，进程不能直接访问硬件设备，当进程需要访问硬件设备（比如读取磁盘文件，接收网络数据等等）时，必须由用户态模式切换至内核态模式，通过系统调用访问硬件设备。strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。

```shell
strace cat /dev/null
```

## IPCS

ipcs 是 Linux 下显示进程间通信设施状态的工具。可以显示消息队列、共享内存和信号量的信息。对于程序员非常有用，普通的系统管理员一般用不到此指令。

```shell
ipcs
```

## VMSTAT

vmstat 是 Virtual Meomory Statistics（虚拟内存统计）的缩写，可实时动态监视操作系统的虚拟内存、进程、CPU活动。

相关字段：

- PROCS:
  - r: 运行队列中进程数量
  - b: 等待IO的进程数量

- MEMORY:
  - swpd: 使用虚拟内存大小
  - free: 可用内存大小
  - buff: 用作缓冲的内存大小
  - cache: 用作缓存的内存大小

- SWAP:
  - si: 每秒从交换区写到内存的大小
  - so: 每秒写入交换区的内存大小

- IO:
  - bi: 每秒读取的块数
  - bo: 每秒写入的块数

- SYSTEM:
  - in: 每秒中断数，包括时钟中断
  - cs: 每秒上下文切换数

- CPU:（以百分比表示）
  - us: 用户进程执行时间( user time )
  - sy: 系统进程执行时间( system time )
  - id: 空闲时间(包括 IO 等待时间)
  - wa: 等待IO时间

使用命令的方式如下：

```shell
vmstat [-V] [-n] [delay [count]]
```

## IOSTAT

iostat 是I/O statistics（输入/输出统计）的缩写，用来动态监视系统的磁盘操作活动。

使用命令的方式如下：

```shell
iostat [arguments] [time] [count]
```

## SAR

sar 是 System Activity Reporter（系统活动情况报告）的缩写。sar 工具将对系统当前的状态进行取样，然后通过计算数据和比例来表达系统的当前运行状态。它的特点是可以连续对系统取样，获得大量的取样数据；取样数据和分析的结果都可以存入文件，所需的负载很小。sar 是目前 Linux 上最为全面的系统性能分析工具之一，可以从 14 个大方面对系统的活动进行报告，包括文件的读写情况、系统调用的使用情况、串口、CPU 效率、内存使用状况、进程活动及 IPC 有关的活动等，使用也是较为复杂。

sar 是查看操作系统报告指标的各种工具中，最为普遍和方便的；它有两种用法:

- 追溯过去的统计数据（默认）
- 周期性的查看当前数据

使用命令的方式如下：

```shell
sar
```

## OBJDUMP

objdump 工具用来显示二进制文件的信息，就是以一种可阅读的格式让你更多地了解二进制文件可能带有的附加信息。

使用命令的方式如下：

```shell
objdump
```

示例的使用方式如下：

```shell
# 查看本机目标结构（使用大端还是小端存储）
objdump -i
```

## NM

nm 命令显示关于指定 File 中符号的信息，文件可以是对象文件、可执行文件或对象文件库。如果文件没有包含符号信息，nm 命令报告该情况，但不把它解释为出错条件。nm 命令缺省情况下报告十进制符号表示法下的数字值。

使用命令的方式如下：

```shell
nm
```

## SIZE

size 的作用是查看程序被映射到内存中的映像所占用的大小信息。

程序映射到内存中，从低地址到高地址依次为下列段：

- 代码段： 只读，可共享; 代码段（ code segment/text segment ）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。

- 数据段： 储存已被初始化了的静态数据。数据段（ data segment ）通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。

- BSS 段：未初始化的数据段. BSS 段（ bss segment ）通常是指用来存放程序中未初始化的全局变量的一块内存区域。BSS 是英文 Block Started by Symbol 的简称。BSS 段属于静态内存分配。

- 堆（ heap ）： 堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用 malloc 等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free 等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）

- 栈 ( stack ) ：栈又称堆栈，是用户存放程序临时创建的局部变量，也就是说我们函数括弧 “{}” 中定义的变量（但不包括 static 声明的变量，static 意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/ 恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。

同时，在高地址还储存了命令行参数及环境变量。

因为内存程序映像中的各段可能位于不同的地址空间中, 它们不一定位于连续的内存块中. 操作系统将程序映像映射到地址空间时, 通常将内存程序映像划分为大小相同的块(也就是page, 页). 只有该页被引用时, 它才被加载到内存中. 不过对于程序员来说, 可以视内存程序映像在逻辑上是连续的。

使用命令的方式如下：

```shell
size <program>
```

## References

[1] 工具参考篇：https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/index.html
[2] 程序内存映像：http://blog.chinaunix.net/uid-9012903-id-2011435.html
